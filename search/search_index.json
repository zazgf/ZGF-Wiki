{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to ZGF Wiki","title":"Home"},{"location":"#welcome-to-zgf-wiki","text":"","title":"Welcome to ZGF Wiki"},{"location":"c%2B%2B/","text":"string \u524d\u8865\u96f6 #include \\ #include \\ #include \\ using namespace std;\\ void main()\\ {\\ int num = 1024;\\ stringstream ss;\\ ss << setw(5) << setfill('0') << num ;\\ string str;\\ ss >> str; //\u5c06\u5b57\u7b26\u6d41\u4f20\u7ed9 str\\ //str = ss.str(); //\u4e5f\u53ef\u4ee5\\ cout << str;\\ } \u5f97\u5230\u5f53\u524d\u65f6\u95f4 #include <iostream> #include <ctime> int main () { time_t rawtime; struct tm * timeinfo; char buffer[80]; time (&rawtime); timeinfo = localtime(&rawtime); strftime(buffer,sizeof(buffer),\"%d-%m-%Y %H:%M:%S\",timeinfo); std::string str(buffer); std::cout << str; return 0; } \u5199\u5165\u6587\u4ef6append #include <fstream> int main() { std::ofstream outfile; outfile.open(\"test.txt\", std::ios_base::app); // append instead of overwrite outfile << \"Data\"; return 0; } float to string to_string(float) string to float stof(str) \u8bfb\u53d6\u6587\u6863\u6bcf\u4e00\u884c\u5185\u5bb9 fstream newfile; newfile.open(learning_file,ios::in); if (newfile.is_open()) { string tp; while(getline(newfile, tp)) { cout << tp << \"\\n\"; } newfile.close(); } \u6587\u4ef6\u6e05\u7a7a fstream newfile; newfile.open(learning_file,ios::out); newfile.close(); \u5b57\u7b26\u4e32\uff53\uff50\uff4c\uff49\uff54 #include <boost/algorithm/string.hpp> std::string text = \"Let me split this into words\"; std::vector<std::string> results; boost::split(results, text, [](char c){return c == ' ';}); CMakeLists.txt \u5f15\u5165\uff42\uff4f\uff4f\uff53\uff54 find_package(Boost COMPONENTS program_options filesystem REQUIRED ) include_directories(${Boost_INCLUDE_DIRS}) link_directories(${Boost_LIBRARY_DIRS}) target_link_libraries(learning ${catkin_LIBRARIES} ${Boost_LIBRARIES}) explicit #include <iostream> using namespace std; class Complex { private: double real; double imag; public: // Default constructor Complex(double r = 0.0, double i = 0.0) : real(r), imag(i) {} // A method to compare two Complex numbers bool operator == (Complex rhs) { return (real == rhs.real && imag == rhs.imag)? true : false; } }; int main() { // a Complex object Complex com1(3.0, 0.0); if (com1 == 3.0) cout << \"Same\"; else cout << \"Not Same\"; return 0; } \u7a0b\u5e8f\u8f93\u51fa\u3000 Same \\ \u5728C ++\u4e2d\uff0c\u5982\u679c\u7c7b\u5177\u6709\u53ef\u4ee5\u7528\u5355\u4e2a\u53c2\u6570\u8c03\u7528\u7684\u6784\u9020\u51fd\u6570\uff0c\u5219\u6b64\u6784\u9020\u51fd\u6570\u5c06\u6210\u4e3a\u8f6c\u6362\u6784\u9020\u51fd\u6570\uff0c\u56e0\u4e3a\u8fd9\u6837\u7684\u6784\u9020\u51fd\u6570\u5141\u8bb8\u5c06\u5355\u4e2a\u53c2\u6570\u8f6c\u6362\u4e3a\u6b63\u5728\u6784\u9020\u7684\u7c7b\u3002\\ \u6211\u4eec\u53ef\u4ee5\u907f\u514d\u8fd9\u79cd\u9690\u5f0f\u8f6c\u6362\uff0c\u56e0\u4e3a\u5b83\u4eec\u53ef\u80fd\u5bfc\u81f4\u610f\u5916\u7684\u7ed3\u679c\u3002\u6211\u4eec\u53ef\u4ee5\u5728explicit\u5173\u952e\u5b57\u7684\u5e2e\u52a9\u4e0b\u4f7f\u6784\u9020\u51fd\u6570\u663e\u5f0f\u5316\u3002\\ using namespace std; class Complex { private: double real; double imag; public: // Default constructor explicit Complex(double r = 0.0, double i = 0.0) : real(r), imag(i) {} // A method to compare two Complex numbers bool operator== (Complex rhs) { return (real == rhs.real && imag == rhs.imag)? true : false; } }; int main() { // a Complex object Complex com1(3.0, 0.0); if (com1 == (Complex)3.0) cout << \"Same\"; else cout << \"Not Same\"; return 0; }","title":"C++"},{"location":"c%2B%2B/#string","text":"#include \\ #include \\ #include \\ using namespace std;\\ void main()\\ {\\ int num = 1024;\\ stringstream ss;\\ ss << setw(5) << setfill('0') << num ;\\ string str;\\ ss >> str; //\u5c06\u5b57\u7b26\u6d41\u4f20\u7ed9 str\\ //str = ss.str(); //\u4e5f\u53ef\u4ee5\\ cout << str;\\ }","title":"string \u524d\u8865\u96f6"},{"location":"c%2B%2B/#_1","text":"#include <iostream> #include <ctime> int main () { time_t rawtime; struct tm * timeinfo; char buffer[80]; time (&rawtime); timeinfo = localtime(&rawtime); strftime(buffer,sizeof(buffer),\"%d-%m-%Y %H:%M:%S\",timeinfo); std::string str(buffer); std::cout << str; return 0; }","title":"\u5f97\u5230\u5f53\u524d\u65f6\u95f4"},{"location":"c%2B%2B/#append","text":"#include <fstream> int main() { std::ofstream outfile; outfile.open(\"test.txt\", std::ios_base::app); // append instead of overwrite outfile << \"Data\"; return 0; }","title":"\u5199\u5165\u6587\u4ef6append"},{"location":"c%2B%2B/#float-to-string","text":"to_string(float)","title":"float to string"},{"location":"c%2B%2B/#string-to-float","text":"stof(str)","title":"string to float"},{"location":"c%2B%2B/#_2","text":"fstream newfile; newfile.open(learning_file,ios::in); if (newfile.is_open()) { string tp; while(getline(newfile, tp)) { cout << tp << \"\\n\"; } newfile.close(); }","title":"\u8bfb\u53d6\u6587\u6863\u6bcf\u4e00\u884c\u5185\u5bb9"},{"location":"c%2B%2B/#_3","text":"fstream newfile; newfile.open(learning_file,ios::out); newfile.close();","title":"\u6587\u4ef6\u6e05\u7a7a"},{"location":"c%2B%2B/#split","text":"#include <boost/algorithm/string.hpp> std::string text = \"Let me split this into words\"; std::vector<std::string> results; boost::split(results, text, [](char c){return c == ' ';});","title":"\u5b57\u7b26\u4e32\uff53\uff50\uff4c\uff49\uff54"},{"location":"c%2B%2B/#cmakeliststxt-boost","text":"find_package(Boost COMPONENTS program_options filesystem REQUIRED ) include_directories(${Boost_INCLUDE_DIRS}) link_directories(${Boost_LIBRARY_DIRS}) target_link_libraries(learning ${catkin_LIBRARIES} ${Boost_LIBRARIES})","title":"CMakeLists.txt \u5f15\u5165\uff42\uff4f\uff4f\uff53\uff54"},{"location":"c%2B%2B/#explicit","text":"#include <iostream> using namespace std; class Complex { private: double real; double imag; public: // Default constructor Complex(double r = 0.0, double i = 0.0) : real(r), imag(i) {} // A method to compare two Complex numbers bool operator == (Complex rhs) { return (real == rhs.real && imag == rhs.imag)? true : false; } }; int main() { // a Complex object Complex com1(3.0, 0.0); if (com1 == 3.0) cout << \"Same\"; else cout << \"Not Same\"; return 0; } \u7a0b\u5e8f\u8f93\u51fa\u3000 Same \\ \u5728C ++\u4e2d\uff0c\u5982\u679c\u7c7b\u5177\u6709\u53ef\u4ee5\u7528\u5355\u4e2a\u53c2\u6570\u8c03\u7528\u7684\u6784\u9020\u51fd\u6570\uff0c\u5219\u6b64\u6784\u9020\u51fd\u6570\u5c06\u6210\u4e3a\u8f6c\u6362\u6784\u9020\u51fd\u6570\uff0c\u56e0\u4e3a\u8fd9\u6837\u7684\u6784\u9020\u51fd\u6570\u5141\u8bb8\u5c06\u5355\u4e2a\u53c2\u6570\u8f6c\u6362\u4e3a\u6b63\u5728\u6784\u9020\u7684\u7c7b\u3002\\ \u6211\u4eec\u53ef\u4ee5\u907f\u514d\u8fd9\u79cd\u9690\u5f0f\u8f6c\u6362\uff0c\u56e0\u4e3a\u5b83\u4eec\u53ef\u80fd\u5bfc\u81f4\u610f\u5916\u7684\u7ed3\u679c\u3002\u6211\u4eec\u53ef\u4ee5\u5728explicit\u5173\u952e\u5b57\u7684\u5e2e\u52a9\u4e0b\u4f7f\u6784\u9020\u51fd\u6570\u663e\u5f0f\u5316\u3002\\ using namespace std; class Complex { private: double real; double imag; public: // Default constructor explicit Complex(double r = 0.0, double i = 0.0) : real(r), imag(i) {} // A method to compare two Complex numbers bool operator== (Complex rhs) { return (real == rhs.real && imag == rhs.imag)? true : false; } }; int main() { // a Complex object Complex com1(3.0, 0.0); if (com1 == (Complex)3.0) cout << \"Same\"; else cout << \"Not Same\"; return 0; }","title":"explicit"}]}